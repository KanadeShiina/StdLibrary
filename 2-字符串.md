# 字符串
## KMP
```C++
char s[N];
int next[N];
int len;
void getnext()
{
	memset(next,0,sizeof(next));
	int j=0,k=-1;
	next[0]=-1;
	while(j<len)
	{
		while(k!=-1&&s[j]!=s[k])
			k=next[k];
		++j;++k;
		next[j]=k;
	}
}

```

## Manacher

```C++
const int N=2e5;

string Mnc(string &s)
{
    string t="$#";
    for(int i=0;i<s.length();++i)//構造輔助串
    {
        t+=s[i];
        t+='#';
    }

    int ml=0,p=0,R=0,M=0;
    //最大長度，最長迴文中心，當前最大迴文串右端，當前最長迴文中心
    
    int len=t.length();
    vector<int> P(len,0);//迴文長度數組
    for(int i=0;i<len;++i)
    {
        P[i]=R>i?min(P[2*M-i],R-i):1;//轉移方程
        
        while(t[i+P[i]]==t[i-P[i]])//長度擴張
            ++P[i];

        if(i+P[i]>R)//更新右端和中心
        {
            R=i+P[i];
            M=i;
        }
        if(ml<P[i])//記錄極大
        {
            ml=P[i];
            p=i;
        }
    }

    return s.substr((p-ml)/2,ml-1);//返回迴文串
}

```
## 后缀数组
```C++

const int N=8e4;
int len;
char s[N];
int c[N],x[N],sa[N],y[N];
//c[i]桶，x[i]第i個元素關鍵字
void getsa()
//y[i]第二關鍵字排名爲i的數，第一關鍵字的位置
{
	int m=130;
	for(int i=0;i<=m;++i)
		c[i]=0;
	for(int i=1;i<=len;++i)//裝桶
		++c[x[i]=s[i]];
	for(int i=2;i<=m;++i)//前綴和把桶變排名
		c[i]+=c[i-1];
	for(int i=len;i>0;--i)//基數排序數組填充
		sa[c[x[i]]--]=i;
	for(int k=1;k<=len;k<<=1)//倍增
	{
		int num=0;
		for(int i=len-k+1;i<=len;++i)//這些第i個沒有第二關鍵字，靠前排
			y[++num]=i;
		for(int i=1;i<=len;++i)
			if(sa[i]>k)//表示可以做別人的第二關鍵字
				y[++num]=sa[i]-k;
		for(int i=1;i<=m;++i)
			c[i]=0;//初始化桶
		for(int i=1;i<=len;++i)//基數排序
			++c[x[i]];
		for(int i=2;i<=m;++i)
			c[i]+=c[i-1];
		for(int i=len;i>0;--i)
		{
			sa[c[x[y[i]]]--]=y[i];//第二關鍵字靠後的，同一個桶裏靠後
			y[i]=0;
		}
		swap(x,y);//保存第一關鍵字到y，備用
		x[sa[1]]=1;
		num=1;
		for(int i=2;i<=len;++i)//構建下一次的第一關鍵字
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]] && y[sa[i]+k]==y[sa[i-1]+k]) ? num:++num;
		if(num==len)
			break;
		m=num;
	}
}

int rk[N],height[N];

void geth()
{
	int k=0;
	for(int i=0;i<=len;++i)
		height[i]=0;
	for(int i=1;i<=len;++i)
		rk[sa[i]]=i;
	for(int i=1;i<=len;++i)
	{
		if(rk[i]==1)//height[1]=0
			continue;
		if(k)
			--k;
		int j=sa[rk[i]-1];
		while(j+k<=len && i+k<=len &&s[i+k]==s[j+k])
			++k;
		height[rk[i]]=k;
	}
}

int minm[N][18];

int RMQ()
{
    int m=(int)(log(len*1.0)/log(2.0));
    for(int i=1;i<=len;++i)
        minm[i][0]=height[i];
    for(int j=1;j<=m;++j)
        for(int i=1;i+(1<<j)-1<=len;++i)
            minm[i][j]=min(minm[i][j-1],minm[i+(1<<(j-1))][j-1]);
}
int query(int a,int b)
{
    int k=int(log(b-a+1.0)/log(2.0));
    return min(minm[a][k],minm[b-(1<<k)+1][k]);
}
int LCP(int a,int b)
{
    a=rk[a],b=rk[b];
    if(a>b)
        swap(a,b);
    return query(a+1,b);
}
```


## 后缀自动机
```C++
char s[N];
int ch[N][26],step[N],pre[N];
int to[N],topo[N],cntr[N],sum[N];
int sz,last;
void ins(int x) 
{
    int np=++sz,p=last;
    last=np;
    step[np]=step[p]+1;
    cntr[np]=1;
    while(!ch[p][x]&&p)
        ch[p][x]=np,p=pre[p];
    if(!p) 
        pre[np]=1;
    else 
    {
        int q=ch[p][x];
        if(step[q]==step[p]+1) 
            pre[np]=q;
        else 
        {
            int nq=++sz;
            step[nq]=step[p]+1;
            for(int i=0;i<26;++i) 
                ch[nq][i]=ch[q][i];
            pre[nq]=pre[q];
            pre[q]=pre[np]=nq;
            while(ch[p][x]==q&&p) 
                ch[p][x]=nq,p=pre[p];
        }
    }
}

void getr() 
{
	for(int i=1;i<=sz;++i) 
        ++to[step[i]];//利用后缀自动机性质拓扑排序
	for(int i=1;i<=sz;++i) 
        to[i]+=to[i-1];
	for(int i=1;i<=sz;++i) 
        topo[to[step[i]]--]=i;
	for(int i=sz;i>=1;--i)
		if(ty) 
            cntr[pre[topo[i]]]+=cntr[topo[i]];
		else 
            cntr[i]=1;
	cntr[1]=0;
	for(int i=sz;i>=1;--i) 
    {
		int x=topo[i];
        sum[x]=cntr[x];//sum:停下或继续，你还能走出多少个子串
		for(int j=0;j<26;++j) 
            if(ch[x][j]) 
                sum[x]+=sum[ch[x][j]];
	}
}
```

## AC自动机
```C++
struct AC_auto
{
    int ch[maxn][26];
    int num[maxn],fail[maxn];
    // f即为fail指针.
    int tot;
	void init()
	{
		tot=0;
		for(int i=0;i<26;++i)
			ch[0][i]=0;
	}
    void insert(char s[],int len)
    {
        int u=0;
        for(int i=0;i<len;i++)
        {
            if(!ch[u][s[i]-'a'])
			{
                ch[u][s[i]-'a']=++tot;
				for(int j=0;j<26;++j)
					ch[tot][j]=0;
				num[tot]=fail[tot]=0;
			}
            u=ch[u][s[i]-'a'];
        }
        num[u]++;
    } //往Trie树里插入元素.
    void build()
    {
        queue<int> q;
        for(int i=0;i<26;i++)
        {
            if(ch[0][i])
				fail[ch[0][i]]=0,
            //第一层与其他单词不可能有公共前后缀,fail直接为根.
            q.push(ch[0][i]);
        }
        while(!q.empty())
        {
            int u=q.front(); q.pop();
            for(int i=0;i<26;i++)
				if(ch[u][i])
				{
					fail[ch[u][i]]=ch[fail[u]][i];
				    q.push(ch[u][i]);
				}
				else 
					ch[u][i]=ch[fail[u]][i];
            //这一步直接省略了查询时的比较.
        }
    } //构建Fail指针.
    int query(char s[],int len) 
    {
        int u=0,ans = 0;
        for(int i=0;i<len;i++)
        {
            u=ch[u][s[i]-'a'];
            for(int j=u;j&&num[j]!=-1;j=fail[j]) 
				ans+=num[j],num[j]=-1;
            //因为直接已经在每个单词的最后面打了标记,所以直接加上即可.
        }
		return ans;
    }
}AC;
```

## 最小表示法
```C++
int getMin(char *s)
{
    int i = 0, j = 1, l;
    int len = strlen(s);
    while(i < len && j < len)
    {
        for(l = 0; l < len; l++)
            if(s[(i + l) % len] != s[(j + l) % len]) break;
        if(l >= len) break;
        if(s[(i + l) % len] > s[(j + l) % len])
        {
            if(i + l + 1 > j) i = i + l + 1;
            else i = j + 1;
        }
        else if(j + l + 1 > i) j = j + l + 1;
        else j = i + 1;
    }
    return i < j ? i : j;
}
 
int getMax(char *s)
{
    int len = strlen(s);
    int i = 0, j = 1, k = 0;
    while(i < len && j < len && k < len)
    {
        int t = s[(i+k)%len]-s[(j+k)%len];
        if(!t) k++;
        else
        {
            if(t > 0)
            {
                if(j+k+1 > i) j = j+k+1;
                else j = i+1;
            }
            else if(i+k+1 > j) i = i+k+1;
            else i = j+1;
            k = 0;
        }
    }
    return i < j ? i : j;
}
```