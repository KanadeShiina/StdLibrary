# 数学
## 欧拉筛
```c++
const int maxn = 1e7 + 10;
int prime[maxn] = {0}, phi[maxn] = {0}, tot;

void euler()
{
    phi[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!phi[i])
        {
            prime[tot++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
}
```

## 筛莫比乌斯函数

```c++
const int maxn = 1e7 + 10;
int prime[maxn], tot = 0, mu[maxn];
bool check[maxn];

void mobius()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}

```

## 莫比乌斯反演，整除分块
$$F(n)=\Sigma_{d|n}f(d)\Rightarrow f(n)=\Sigma_{d|n}\mu(d)F(\frac{d}{n})$$
$$F(n)=\Sigma_{n|d}f(d)\Rightarrow f(n)=\Sigma_{n|d}\mu(\frac{d}{n})F(d)$$

```c++
ll prime[maxn], tot = 0, mu[maxn], sum[maxn];
bool check[maxn];

void getmu()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i < maxn; i++) //前缀和
        sum[i] = sum[i - 1] + mu[i];
}

ll cal(int a, int b) //整除分块 i:1->a  j:1->b  gcd(i,j)=1对数
{
    if (a > b)
        swap(a, b);
    ll l = 1, r, ans = 0;
    while (l <= a)
    {
        r = min(a / (a / l), b / (b / l));
        ans += (sum[r] - sum[l - 1]) * (a / l) * (b / l);
        l = r + 1;
    }
    return ans;
}

```

## 常见狄利克雷卷积
### 积性函数
$$\epsilon(n)=[n=1]$$
$$1(n)=1$$
$$Id(n)=n$$
$$d(n)=\Sigma_{d|n}1$$
$$\sigma(n)=\Sigma_{d|n}d$$
### 卷积
$$\mu * 1 =\epsilon$$
$$\phi * 1=Id$$
$$1*1=d$$

## 杜教筛
$O(n^{2/3})$求积性函数前缀和。  
假设要求的积性函数为$f$，前缀和为$S$，能找到较为简单(前缀和好求)的积性函数$g$，使得$f*g=h$前缀和容易求出。那么有:
$$g(1)S(n)=\Sigma_{i=1}^{n}h(i)-\Sigma_{d=2}^{n}g(d)\cdot S(\lfloor n/d \rfloor)$$  
其中$g(1)$一般来说都是1，$h$和$g$的前缀和需要比较好算，然后就能记忆化搜索了。  

```c++ 
	//杜教筛欧拉函数 原理: phi * I = Id
	const int maxn=1e6+10;			//通常预处理到n^2/3为最优
	ll phi[maxn];
    unordered_map<int,ll> phi2;		//hash
    
	ll djsphi(int n)
	{
    	if (n < maxn)
        	return phi[n];
    	if (phi2[n])
        	return phi2[n];
    	ll ans = 1ll * n * (n + 1) / 2;	
    	for (int l = 2, r; l <= n; l = r + 1)
    	{
        	r = n / (n / l);
        	ans -= djsphi(n / l) * (r - l + 1);
    	}
    	return phi2[n] = ans;	//记忆化
	}

```

## 快速幂
```c++
ll quick(ll a, ll b)
{
    ll ret = 1;
    while (b)
    {
        if (b & 1)
            ret = ret * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ret;
}
```
## 快速乘
```c++
ll mul(ll a, ll b, ll m)
{
    ll ret = 0;
    while (b)
    {
        if (b & 1)
        {
            ret += a;
            if (ret >= m)
                ret -= m;
        }
        a += a;
        if (a >= m)
            a -= m;
        b >>= 1;
    }
    return ret;
}
```
```c++
ll mul(ll a, ll b, ll m)
{
    return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll mul(ll a, ll b, ll m)
{
    ll t = a * b - ll((long double)a * b / m) * m;
    return t < 0 ? t + m : t;
}
```  

## 扩展欧几里得算法
求解$a\cdot x+b\cdot y=gcd(a,b)$的一组特解。
```c++
ll exgcd(ll a, ll b, ll &x, ll &y) //返回gcd(a,b)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= x * (a / b);
    return d;
}
```

## 逆元
1. 使用费马小定理，要求模数p为素数。
2. 使用扩展欧几里得定理，不要求模数p为素数。  
```c++
ll inv(ll a, ll p) //求a关于p的逆元
{
    ll x, y;
    ll d = exgcd(a, p, x, y);
    if (d != 1)
        return -1;
    return (x % p + p) % p;
}
```
3. 基于$inv(a)=(p- \lfloor p/a \rfloor)*inv(p\%a)\%p$，在$O(n)$时间复杂度下求出逆元表。
```c++
void init()
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * 1LL * inv[mod % i] % mod;
}
```

## 组合数
$O(n)$时间复杂度内预处理出n以内的组合数。
```c++
void init() //inv,f,finv 都开ll
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod; //inv: 逆元
    f[0] = finv[0] = 1;                                //f: 阶乘 	finv:阶乘逆元(1/f)
    for (int i = 1; i < maxn; i++)
    {
        f[i] = f[i - 1] * i % mod;
        finv[i] = finv[i - 1] * inv[i] % mod;
    }
}

ll C(int n, int m) //C(n,m)
{
    if (m < 0 || m > n)
        return 0;
    return f[n] * finv[n - m] % mod * finv[m] % mod;
}
```

## Fast Transfroming
### FFT
* 复数类实现，n为2的幂次
```c++
typedef double LD;
const LD PI = 3.14159265358979;
struct C
{
    LD r, i;
    C(LD r = 0, LD i = 0) : r(r), i(i) {}
    C operator+(const C &a) const
    {
        return C(r + a.r, i + a.i);
    }
    C operator-(const C &a) const
    {
        return C(r - a.r, i - a.i);
    }
    C operator*(const C &a) const
    {
        return C(r * a.r - i * a.i, r * a.i + i * a.r);
    }
};
void FFT(C x[], int n, int p)
{
    for (int i = 0, t = 0; i < n; ++i)
    {
        if (i > t)
            swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1)
            ;
    }
    for (int h = 2; h <= n; h <<= 1)
    {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h)
        {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j)
            {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1)
        for (int i = 0; i < n; ++i)
            x[i].r /= n;
}
void conv(C a[], C b[], int n)
{
    FFT(a, n, 1);
    FFT(b, n, 1);
    for (int i = 0; i < n; ++i)
        a[i] = a[i] * b[i];
    FFT(a, n, -1);
}
```

## 离散对数
### BSGS
* ~~北上广深,拔山盖世~~应用于模数为质数
```c++
ll BSGS(ll a, ll b, ll p) // a^x = b (mod p)
{
    a %= p;
    if (!a && !b)
        return 1;
    if (!a)
        return -1;
    static map<ll, ll> mp;
    mp.clear();
    ll m = sqrt(p + 1.5);
    ll v = 1;
    for (int i = 1; i < m + 1; ++i)
    {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    ll vv = v;
    for (int i = 1; i < m + 1; ++i)
    {
        auto it = mp.find(vv);
        if (it != mp.end())
            return i * m - it->second;
        vv = vv * v % p;
    }
    return -1;
}
```

## 中国剩余定理
* 逐项合并，支持不互质，无解返回-1
* 前置exgcd

```c++
ll CRT(ll *m, ll *r, ll n)
{
    if (!n)
        return 0;
    ll M = m[0], R = r[0], x, y, d;
    for (int i = 1; i < n; i++)
    {
        d = exgcd(M, m[i], x, y);
        if ((r[i] - R) % d)
            return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R >= 0 ? R : R + M;
}
```

## 博弈
* 巴什博弈：P态为 $n\equiv 0(mod\ m+1)$
* 阶梯博弈：阶梯博弈等效为奇数号阶梯的nim博弈
* 威佐夫博弈：有两堆各若干个物品，两个人轮流从某一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
P态为$(y-x)\times \frac{\sqrt{5}+1}{2}=x$
* NP图、SG函数找规律，博弈dp
* 考虑模仿操作