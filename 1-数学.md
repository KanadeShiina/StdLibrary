# 数学
## 欧拉筛
```c++
const int maxn=1e7+10;
int prime[maxn]={0},phi[maxn]={0},tot;

void euler()
{
	phi[1]=1;
	for(int i=2;i<maxn;i++)
    {
    	if(!phi[i])
        {
        	prime[tot++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j<tot&&i*prime[j]<maxn;j++)
        {
        	if(i%prime[j]==0)
            {
            	phi[i*prime[j]]=phi[i]*prime[j];
                break;
			}
            phi[i*prime[j]]=phi[i]*phi[prime[j]];
        }
    }
}
```

## 筛莫比乌斯函数

```c++
const int maxn=1e7+10;
int prime[maxn],tot=0,mu[maxn];
bool check[maxn];

void mobius()
{
	mu[1]=1;
    for(int i=2;i<maxn;i++)
    {
    	if(!check[i])
        {
        	prime[tot++]=i;
            mu[i]=-1;
        }
        for(int j=0;j<tot&&i*prime[j]<maxn;j++)
        {
        	check[i*prime[j]]=true;
            if(i%prime[j]==0)
            {
            	mu[i*prime[j]]=0;
                break;
            }
            mu[i*prime[j]]=-mu[i];
        }
    }
}

```

## 莫比乌斯反演，整除分块
$$F(n)=\Sigma_{d|n}f(d)\Rightarrow f(n)=\Sigma_{d|n}\mu(d)F(\frac{d}{n})$$
$$F(n)=\Sigma_{n|d}f(d)\Rightarrow f(n)=\Sigma_{n|d}\mu(\frac{d}{n})F(d)$$

```c++
ll prime[maxn],tot=0,mu[maxn],sum[maxn];
bool check[maxn];

void getmu()
{
    mu[1]=1;
    for(int i=2;i<maxn;i++)
    {
        if(!check[i])
        {
            prime[tot++]=i;
            mu[i]=-1;
        }
        for(int j=0;j<tot&&i*prime[j]<maxn;j++)
        {
            check[i*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i*prime[j]]=0;
                break;
            }
            mu[i*prime[j]]=-mu[i];
        }
    }
    for(int i=1;i<maxn;i++)     //前缀和
        sum[i]=sum[i-1]+mu[i];
}

ll cal(int a,int b)             //整除分块 i:1->a  j:1->b  gcd(i,j)=1对数
{
    if(a>b)     swap(a,b);
    ll l=1,r,ans=0;
    while(l<=a)
    {
        r=min(a/(a/l),b/(b/l));
        ans+=(sum[r]-sum[l-1])*(a/l)*(b/l);
        l=r+1;
    }
    return ans;
}

```

## 常见狄利克雷卷积
### 积性函数
$$\epsilon(n)=[n=1]$$
$$1(n)=1$$
$$Id(n)=n$$
$$d(n)=\Sigma_{d|n}1$$
$$\sigma(n)=\Sigma_{d|n}d$$
### 卷积
$$\mu * 1 =\epsilon$$
$$\phi * 1=Id$$
$$1*1=d$$

## 快速幂
```c++
long long quick(long long a,long long b)
{
	long long ret=1;
	while(b)
	{
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ret;
}
```
## 快速乘
```c++
ll mul(ll a,ll b,ll m)
{
	ll ret=0;
	while(b)
	{
		if(b&1)
		{
			ret+=a;
			if(ret>=m) ret-=m;
		}
		a+=a;
		if(a>=m) a-=m;
		b>>=1;
	}
	return ret;
}
```
```c++
ll mul(ll a,ll b,ll m)
{
	return (a * b-ll((long double) a * b / m) * m + m) % m;
}
ll mul(ll a,ll b,ll m)
{
	ll t = a * b - ll((long double) a * b / m) * m;
	return t < 0 ? t + m : t;
}
```  

## 扩展欧几里得算法
求解$a\cdot x+b\cdot y=gcd(a,b)$的一组特解。
```c++
ll exgcd(ll a,ll b,ll& x,ll& y)		//返回gcd(a,b)
{
	if(b==0)
    {
    	x=1,y=0;
        return a;
    }
    ll d=exgcd(b,a%b,y,x);
    y-=x*(a/b);
    return d;
}
```

## 逆元
1. 使用费马小定理，要求模数p为素数。
2. 使用扩展欧几里得定理，不要求模数p为素数。  
```c++
ll inv(ll a,ll p)	//求a关于p的逆元
{
    ll x,y;
    ll d=exgcd(a,p,x,y);
    if(d!=1)
    	return -1;
	return (x%p+p)%p;
}
```
3. 基于$inv(a)=(p- \lfloor p/a \rfloor)*inv(p\%a)\%p$，在$O(n)$时间复杂度下求出逆元表。
```c++
void init()
{
	inv[1]=1;
    for(int i=2;i<maxn;i++)
    	inv[i]=(mod-mod/i)*1LL*inv[mod%i]%mod;
}
```

## 组合数
$O(n)$时间复杂度内预处理出n以内的组合数。
```c++
void init()										//inv,f,finv 都开ll
{
    inv[1]=1;
    for(int i=2;i<maxn;i++)
    	inv[i]=(mod-mod/i)*inv[mod%i]%mod;		//inv: 逆元
    f[0]=finv[0]=1;								//f: 阶乘 	finv:阶乘逆元(1/f)
    for(int i=1;i<maxn;i++)
    {
    	f[i]=f[i-1]*i%mod;
    	finv[i]=finv[i-1]*inv[i]%mod;
    }
}

ll C(int n,int m)								//C(n,m)
{
    if(m<0||m>n) return 0;
    return f[n]*finv[n-m]%mod*finv[m]%mod;
}
```

## Fast Transfroming
### FFT
* 复数类实现，n为2的幂次
```c++
typedef double LD;
const LD PI=3.14159265358979;
struct C{
	LD r,i;
	C(LD r=0,LD i=0):r(r),i(i){}
	C operator +(const C& a)const{
		return C(r + a.r, i + a.i);
	}
	C operator -(const C& a)const{
		return C(r - a.r, i - a.i);
	}
	C operator *(const C& a)const{
		return C(r * a.r - i * a.i,r * a.i + i * a.r);
	}
};
void FFT(C x[],int n,int p)
{
	for(int i = 0, t = 0; i < n; ++i)
	{
		if(i > t) swap(x[i], x[t]);
		for(int j = n >> 1;(t ^= j) < j; j >>= 1);
	}
	for(int h = 2;h <= n;h <<= 1)
	{
		C wn(cos(p * 2 * PI / h),sin(p * 2 * PI / h));
		for(int i = 0; i < n; i += h)
		{
			C w(1,0),u;
			for(int j = i, k = h >> 1;j < i + k; ++j)
			{
				u = x[j + k] * w;
				x[j + k] = x[j] - u;
				x[j] = x[j] + u;
				w = w * wn;
			}
		}
	}
	if (p == -1)
		for(int i=0;i<n;++i)
			x[i].r /= n;
}
void conv(C a[],C b[],int n)
{
	FFT(a,n,1);
	FFT(b,n,1);
	for(int i=0;i<n;++i)
		a[i]=a[i]*b[i];
	FFT(a,n,-1);
}
```

## 离散对数
### BSGS
* ~~北上广深,拔山盖世~~应用于模数为质数
```c++
ll BSGS(ll a, ll b, ll p) // a^x = b (mod p)
{
	a %= p;
	if (!a && !b) return 1;
	if (!a) return -1;
	static map<ll, ll> mp; mp.clear();
	ll m = sqrt(p + 1.5);
	ll v = 1;
	for (int i=1;i<m+1; ++i) 
	{
		v = v * a % p;
		mp[v * b % p] = i;
	}
	ll vv = v;
	for (int i=1 ;i<m+1;++i) 
	{
		auto it = mp.find(vv);
		if (it != mp.end()) return i * m - it->second;
		vv = vv * v % p;
	}
	return -1;
}
```

## 中国剩余定理
* 逐项合并，支持不互质，无解返回-1
* 前置exgcd

```c++
ll CRT(ll *m, ll *r, ll n) 
{
    if (!n) return 0;
    ll M = m[0], R = r[0], x, y, d;
    for(int i = 1; i < n; i++)
	{
    	d = exgcd(M, m[i], x, y);
        if ((r[i] - R) % d) return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R >= 0 ? R : R + M;
}
```