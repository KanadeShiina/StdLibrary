# 数学
## 欧拉筛
```c++
const int maxn = 1e7 + 10;
int prime[maxn] = {0}, phi[maxn] = {0}, tot;

void euler()
{
    phi[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!phi[i])
        {
            prime[tot++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
}
```

## 筛莫比乌斯函数

```c++
const int maxn = 1e7 + 10;
int prime[maxn], tot = 0, mu[maxn];
bool check[maxn];

void mobius()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}

```

## 莫比乌斯反演，整除分块
$$F(n)=\Sigma_{d|n}f(d)\Rightarrow f(n)=\Sigma_{d|n}\mu(d)F(\frac{d}{n})$$
$$F(n)=\Sigma_{n|d}f(d)\Rightarrow f(n)=\Sigma_{n|d}\mu(\frac{d}{n})F(d)$$

```c++
ll prime[maxn], tot = 0, mu[maxn], sum[maxn];
bool check[maxn];

void getmu()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i < maxn; i++) //前缀和
        sum[i] = sum[i - 1] + mu[i];
}

ll cal(int a, int b) //整除分块 i:1->a  j:1->b  gcd(i,j)=1对数
{
    if (a > b)
        swap(a, b);
    ll l = 1, r, ans = 0;
    while (l <= a)
    {
        r = min(a / (a / l), b / (b / l));
        ans += (sum[r] - sum[l - 1]) * (a / l) * (b / l);
        l = r + 1;
    }
    return ans;
}

```

## 常见狄利克雷卷积
### 积性函数
$$\epsilon(n)=[n=1]$$
$$1(n)=1$$
$$Id(n)=n$$
$$d(n)=\Sigma_{d|n}1$$
$$\sigma(n)=\Sigma_{d|n}d$$
### 卷积
$$\mu * 1 =\epsilon$$
$$\phi * 1=Id$$
$$1*1=d$$

## 杜教筛
$O(n^{2/3})$求积性函数前缀和。  
假设要求的积性函数为$f$，前缀和为$S$，能找到较为简单(前缀和好求)的积性函数$g$，使得$f*g=h$前缀和容易求出。那么有:
$$g(1)S(n)=\Sigma_{i=1}^{n}h(i)-\Sigma_{d=2}^{n}g(d)\cdot S(\lfloor n/d \rfloor)$$  
其中$g(1)$一般来说都是1，$h$和$g$的前缀和需要比较好算，然后就能记忆化搜索了。  

```c++ 
	//杜教筛欧拉函数 原理: phi * I = Id
	const int maxn=1e6+10;			//通常预处理到n^2/3为最优
	ll phi[maxn];
    unordered_map<int,ll> phi2;		//hash
    
	ll djsphi(int n)
	{
    	if (n < maxn)
        	return phi[n];
    	if (phi2[n])
        	return phi2[n];
    	ll ans = 1ll * n * (n + 1) / 2;	
    	for (int l = 2, r; l <= n; l = r + 1)
    	{
        	r = n / (n / l);
        	ans -= djsphi(n / l) * (r - l + 1);
    	}
    	return phi2[n] = ans;	//记忆化
	}

```

## 快速幂
```c++
ll quick(ll a, ll b)
{
    ll ret = 1;
    while (b)
    {
        if (b & 1)
            ret = ret * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ret;
}
```
## 快速乘
```c++
ll mul(ll a, ll b, ll m)
{
    ll ret = 0;
    while (b)
    {
        if (b & 1)
        {
            ret += a;
            if (ret >= m)
                ret -= m;
        }
        a += a;
        if (a >= m)
            a -= m;
        b >>= 1;
    }
    return ret;
}
```
```c++
ll mul(ll a, ll b, ll m)
{
    return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll mul(ll a, ll b, ll m)
{
    ll t = a * b - ll((long double)a * b / m) * m;
    return t < 0 ? t + m : t;
}
```  

## 扩展欧几里得算法
求解$a\cdot x+b\cdot y=gcd(a,b)$的一组特解。
```c++
ll exgcd(ll a, ll b, ll &x, ll &y) //返回gcd(a,b)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= x * (a / b);
    return d;
}
```

## 类欧几里得算法
$$F(a,b,c,n)=\Sigma_{i=0}^{n}\lfloor\frac{a*i+b}{c}\rfloor$$
$$G(a,b,c,n)=\Sigma_{i=0}^{n}\lfloor i*\frac{a*i+b}{c}\rfloor$$
$$H(a,b,c,n)=\Sigma_{i=0}^{n}(\lfloor \frac{a*i+b}{c}\rfloor)^2$$
通用方法：
1.   当$a\ge c$或者$b\ge c$时，通过$\lfloor \frac{a}{c} \rfloor = \lfloor \frac{a\%c}{c} \rfloor +\lfloor \frac{a}{c} \rfloor $ 展开化简。
2.   当$a < c$且$b < c$时，通过枚举直线下的点，交换枚举顺序展开化简后递归求解。
3.   注意边界条件： $a=0$，$n=0$。
4.   需要自己写多项取模相加/减/乘。

```c++
typedef long long ll;							
const ll mod=998244353,inv2=499122177,inv6=166374059;			
struct node										//分别代表F,G,H
{
    ll f,g,h;
    node(){}
    node(ll _f,ll _g,ll _h):f(_f),g(_g),h(_h){}
};

node solve(ll a,ll b,ll c,ll n)					
{
    if(!n)  return (node){b/c,0,mul(b/c,b/c)};
    if(!a)  return (node){mul(n+1,b/c),mul4(n,n+1,inv2,b/c),mul3(b/c,b/c,n+1)};
    if(a>=c||b>=c)
    {
        node t=solve(a%c,b%c,c,n);
        return (node){add(add(t.f,mul(mul(mul(n,n+1),inv2),a/c)),mul(n+1,b/c)),
        add3(mul5(a/c,inv6,n,n+1,2*n+1),mul4(b/c,inv2,n,n+1),t.g),
        add6(mul(mul(a/c,a/c),mul4(inv6,n,n+1,2*n+1)),mul3(b/c,b/c,n+1),
        t.h,mul4(n,n+1,a/c,b/c),mul3(2,b/c,t.f),mul3(2,a/c,t.g))};
    }
    ll m=(a*n+b)/c;
    node t=solve(c,c-b-1,a,m-1);
    return (node){add(n*m,mod-t.f),mul(inv2,sub(sub(mul3(n,n+1,m),t.h),t.f)),
    sub(sub(mul3(n,m,m),mul(2,t.g)),t.f)};
}
```

## 逆元
1. 使用费马小定理，要求模数p为素数。
2. 使用扩展欧几里得定理，不要求模数p为素数。  
```c++
ll inv(ll a, ll p) //求a关于p的逆元
{
    ll x, y;
    ll d = exgcd(a, p, x, y);
    if (d != 1)
        return -1;
    return (x % p + p) % p;
}
```
3. 基于$inv(a)=(p- \lfloor p/a \rfloor)*inv(p\%a)\%p$，在$O(n)$时间复杂度下求出逆元表。
```c++
void init()
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * 1LL * inv[mod % i] % mod;
}
```

## 组合数
$O(n)$时间复杂度内预处理出n以内的组合数。
```c++
void init() //inv,f,finv 都开ll
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod; //inv: 逆元
    f[0] = finv[0] = 1;                                //f: 阶乘 	finv:阶乘逆元(1/f)
    for (int i = 1; i < maxn; i++)
    {
        f[i] = f[i - 1] * i % mod;
        finv[i] = finv[i - 1] * inv[i] % mod;
    }
}

ll C(int n, int m) //C(n,m)
{
    if (m < 0 || m > n)
        return 0;
    return f[n] * finv[n - m] % mod * finv[m] % mod;
}
```

## 线性递推
### BM模板
要求:
1. 线性递推
2. 所有数都有逆元
3. 给出的前n项越多越精确  

```c++
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;        //修改成题目要求的模数
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head
int _,n;
namespace linear_seq {
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<int> Md;
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
        //        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};
int main() 
{
    while (~scanf("%d",&n)) 
    {
        vector<int>v;       //输入前几项(一般8项足够)
        v.push_back(1);
        v.push_back(1);
        v.push_back(2);
        v.push_back(3);
        v.push_back(5);
        v.push_back(8);
        //VI{1,1,2,3,5,8}		解出斐波那契数列
        printf("i:%d  arr:%d\n",n,linear_seq::gao(v,n-1));
    }
}

```

## Fast Transfroming
### FFT
* 复数类实现，n为2的幂次
```c++
typedef double LD;
const LD PI = 3.14159265358979;
struct C
{
    LD r, i;
    C(LD r = 0, LD i = 0) : r(r), i(i) {}
    C operator+(const C &a) const
    {
        return C(r + a.r, i + a.i);
    }
    C operator-(const C &a) const
    {
        return C(r - a.r, i - a.i);
    }
    C operator*(const C &a) const
    {
        return C(r * a.r - i * a.i, r * a.i + i * a.r);
    }
};
void FFT(C x[], int n, int p)
{
    for (int i = 0, t = 0; i < n; ++i)
    {
        if (i > t)
            swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1)
            ;
    }
    for (int h = 2; h <= n; h <<= 1)
    {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h)
        {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j)
            {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1)
        for (int i = 0; i < n; ++i)
            x[i].r /= n;
}
void conv(C a[], C b[], int n)
{
    FFT(a, n, 1);
    FFT(b, n, 1);
    for (int i = 0; i < n; ++i)
        a[i] = a[i] * b[i];
    FFT(a, n, -1);
}
```

## 离散对数
### BSGS
* ~~北上广深,拔山盖世~~应用于模数为质数
```c++
ll BSGS(ll a, ll b, ll p) // a^x = b (mod p)
{
    a %= p;
    if (!a && !b)
        return 1;
    if (!a)
        return -1;
    static map<ll, ll> mp;
    mp.clear();
    ll m = sqrt(p + 1.5);
    ll v = 1;
    for (int i = 1; i < m + 1; ++i)
    {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    ll vv = v;
    for (int i = 1; i < m + 1; ++i)
    {
        auto it = mp.find(vv);
        if (it != mp.end())
            return i * m - it->second;
        vv = vv * v % p;
    }
    return -1;
}
```

## 二次剩余
* $x==-1$ 时 无根
* 否则有两个解: $x$ , $p-x$
```
ll q1, q2, w;
struct P { // x + y * sqrt(w)
    ll x, y;
};

P pmul(const P& a, const P& b, ll p) {
    P res;
    res.x = (a.x * b.x + a.y * b.y % p * w) % p;
    res.y = (a.x * b.y + a.y * b.x) % p;
    return res;
}

P bin(P x, ll n, ll MOD) {
    P ret = {1, 0};
    for (; n; n >>= 1, x = pmul(x, x, MOD))
        if (n & 1) ret = pmul(ret, x, MOD);
    return ret;
}
ll Legendre(ll a, ll p) { return bin(a, (p - 1) >> 1, p); }

ll equation_solve(ll b, ll p) {
    if(b==0)    return 0;
    if (p == 2) return 1;
    if ((Legendre(b, p) + 1) % p == 0)
        return -1;
    ll a;
    while (true) {
        a = rand() % p;
        w = ((a * a - b) % p + p) % p;
        if ((Legendre(w, p) + 1) % p == 0)
            break;
    }
    return bin({a, 1}, (p + 1) >> 1, p).x;
}



```

## 中国剩余定理
* 逐项合并，支持不互质，无解返回-1
* 前置exgcd

```c++
ll CRT(ll *m, ll *r, ll n)
{
    if (!n)
        return 0;
    ll M = m[0], R = r[0], x, y, d;
    for (int i = 1; i < n; i++)
    {
        d = exgcd(M, m[i], x, y);
        if ((r[i] - R) % d)
            return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R >= 0 ? R : R + M;
}
```

## 素数测试
### miller_rabin
```c++
ll power(ll v, ll p, ll m)
{
    ll r = 1;
    while (p)
    {
        if (p & 1)
            r = r * v % m;
        v = v * v % m;
        p >>= 1;
    }

    return r;
}

bool witness(ll a, ll p)
{
    int k = 0;
    ll q = p - 1;
    while ((q & 1) == 0)
        ++k, q >>= 1;
    ll v = power(a, q, p);
    if (v == 1 || v == p - 1)
        return false; // probably prime number
    while (k-- != 0)
    {
        v = v * v % p;
        if (v == p - 1)
            return false;
    }

    return true; // composite number
}

bool miller_rabin(ll p)
{
    if (p == 1)
        return false;
    if (p == 2)
        return true;
    if (p % 2 == 0)
        return false;

    for (int i = 0; i != 50; ++i)
    {
        ll a = std::rand() % (p - 1) + 1;
        if (witness(a, p))
            return false;
    }

    return true;
}

```


## 博弈
* 巴什博弈：P态为 $n\equiv 0(mod\ m+1)$
* 阶梯博弈：阶梯博弈等效为奇数号阶梯的nim博弈
* 威佐夫博弈：有两堆各若干个物品，两个人轮流从某一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
P态为$(y-x)\times \frac{\sqrt{5}+1}{2}=x$
* NP图、SG函数找规律，博弈dp
* 考虑模仿操作
