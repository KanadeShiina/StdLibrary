# 数学
## 欧拉筛
```c++
const int maxn = 1e7 + 10;
int prime[maxn] = {0}, phi[maxn] = {0}, tot;

void euler()
{
    phi[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!phi[i])
        {
            prime[tot++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
}
```

## 筛莫比乌斯函数

```c++
const int maxn = 1e7 + 10;
int prime[maxn], tot = 0, mu[maxn];
bool check[maxn];

void mobius()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}

```

## 莫比乌斯反演，整除分块
$$F(n)=\Sigma_{d|n}f(d)\Rightarrow f(n)=\Sigma_{d|n}\mu(d)F(\frac{d}{n})$$
$$F(n)=\Sigma_{n|d}f(d)\Rightarrow f(n)=\Sigma_{n|d}\mu(\frac{d}{n})F(d)$$

```c++
ll prime[maxn], tot = 0, mu[maxn], sum[maxn];
bool check[maxn];

void getmu()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; i++)
    {
        if (!check[i])
        {
            prime[tot++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < tot && i * prime[j] < maxn; j++)
        {
            check[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i < maxn; i++) //前缀和
        sum[i] = sum[i - 1] + mu[i];
}

ll cal(int a, int b) //整除分块 i:1->a  j:1->b  gcd(i,j)=1对数
{
    if (a > b)
        swap(a, b);
    ll l = 1, r, ans = 0;
    while (l <= a)
    {
        r = min(a / (a / l), b / (b / l));
        ans += (sum[r] - sum[l - 1]) * (a / l) * (b / l);
        l = r + 1;
    }
    return ans;
}

```

## 公式

### 一些数论公式

* 当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x \; mod \; \phi(p) + \phi(p)}\pmod p$
* $\mu^2(n)=\sum_{d^2|n} \mu(d)$
* $\sum_{d|n} \varphi(d)=n$
* $\sum_{d|n} 2^{\omega(d)}=\sigma_0(n^2)$，其中 $\omega$ 是不同素因子个数
* $\sum_{d|n} \mu^2(d)=2^{\omega(d)}$

### 一些数论函数求和的例子

* $\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$
* $\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor  \lfloor \frac m {dx} \rfloor$
* $\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$
* $S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d < i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$
  * 利用 $[n=1] = \sum_{d|n} \mu(d)$
* $S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d<i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$
  * 利用 $n = \sum_{d|n} \varphi(d)$
* $\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$ 
* $\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \\
  \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$
* $\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$

### 斐波那契数列性质

* $F_{a+b}=F_{a-1} \cdot F_b+F_a \cdot F_{b+1}$
* $F_1+F_3+\dots +F_{2n-1} = F_{2n},F_2 + F_4 + \dots + F_{2n} = F_{2n + 1} - 1$
* $\sum_{i=1}^n F_i = F_{n+2} - 1$
* $\sum_{i=1}^n F_i^2 = F_n \cdot F_{n+1}$
* $F_n^2=(-1)^{n-1} + F_{n-1} \cdot F_{n+1}$
* $gcd(F_a, F_b)=F_{gcd(a, b)}$
* 模 $n$ 周期（皮萨诺周期）
  * $\pi(p^k) = p^{k-1} \pi(p)$
  * $\pi(nm) = lcm(\pi(n), \pi(m)), \forall n \perp m$
  * $\pi(2)=3, \pi(5)=20$
  * $\forall p \equiv \pm 1\pmod {10}, \pi(p)|p-1$
  * $\forall p \equiv \pm 2\pmod {5}, \pi(p)|2p+2$

### 常见生成函数

* $(1+ax)^n=\sum_{k=0}^n \binom {n}{k} a^kx^k$
* $\dfrac{1-x^{r+1}}{1-x}=\sum_{k=0}^nx^k$
* $\dfrac1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$
* $\dfrac 1{(1-x)^2}=\sum_{k=0}^{\infty}(k+1)x^k$
* $\dfrac1{(1-x)^n}=\sum_{k=0}^{\infty} \binom{n+k-1}{k}x^k$
* $e^x=\sum_{k=0}^{\infty}\dfrac{x^k}{k!}$
* $\ln(1+x)=\sum_{k=0}^{\infty}\dfrac{(-1)^{k+1}}{k}x^k$

### 佩尔方程

若一个丢番图方程具有以下的形式：$x^2 - ny^2= 1$。且 $n$ 为正整数，则称此二元二次不定方程为**佩尔方程**。

若 $n$ 是完全平方数，则这个方程式只有平凡解 $(\pm 1,0)$（实际上对任意的 $n$，$(\pm 1,0)$ 都是解）。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\sqrt{n}$ 的连分数求出。

$x = [a_0; a_1, a_2, a_3]=x = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots\,}}}}$

设 $\tfrac{p_i}{q_i}$ 是 $\sqrt{n}$ 的连分数表示：$[a_{0}; a_{1}, a_{2}, a_{3}, \,\ldots ]$ 的渐近分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解，或最小解，记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式：$x_{i}+y_{i}{\sqrt  n}=(x_{1}+y_{1}{\sqrt  n})^{i}$。或者由以下的递回关系式得到：

$\displaystyle x_{i+1} = x_1 x_i + n y_1 y_i$, $\displaystyle y_{{i+1}}=x_{1}y_{i}+y_{1}x_{i}$。

**但是：**佩尔方程千万不要去推（虽然推起来很有趣，但结果不一定好看，会是两个式子）。记住佩尔方程结果的形式通常是 $a_n=ka_{n−1}−a_{n−2}$（$a_{n−2}$ 前的系数通常是 $−1$）。暴力 / 凑出两个基础解之后加上一个 $0$，容易解出 $k$ 并验证。

### Burnside & Polya

* $|X/G|={\frac  {1}{|G|}}\sum _{{g\in G}}|X^{g}|$

注：$X^g$ 是 $g$ 下的不动点数量，也就是说有多少种东西用 $g$ 作用之后可以保持不变。

* $|Y^X/G| = \frac{1}{|G|}\sum_{g \in G} m^{c(g)}$

注：用 $m$ 种颜色染色，然后对于某一种置换 $g$，有 $c(g)$ 个置换环，为了保证置换后颜色仍然相同，每个置换环必须染成同色。

### 皮克定理

$2S = 2a+b-2$

* $S$ 多边形面积
* $a$ 多边形内部点数
* $b$ 多边形边上点数

### 莫比乌斯反演

* $g(n) = \sum_{d|n} f(d) \Leftrightarrow f(n) = \sum_{d|n} \mu (d) g( \frac{n}{d})$
* $f(n)=\sum_{n|d}g(d) \Leftrightarrow g(n)=\sum_{n|d} \mu(\frac{d}{n}) f(d)$

### 低阶等幂求和

* $\sum_{i=1}^{n} i^{1} = \frac{n(n+1)}{2} = \frac{1}{2}n^2 +\frac{1}{2} n$
* $\sum_{i=1}^{n} i^{2} = \frac{n(n+1)(2n+1)}{6} = \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n$
* $\sum_{i=1}^{n} i^{3} = \left[\frac{n(n+1)}{2}\right]^{2} = \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2$
* $\sum_{i=1}^{n} i^{4} = \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n$
* $\sum_{i=1}^{n} i^{5} = \frac{n^{2}(n+1)^{2}(2n^2+2n-1)}{12} = \frac{1}{6}n^6 + \frac{1}{2}n^5 + \frac{5}{12}n^4 - \frac{1}{12}n^2$

### 一些组合公式

* 错排公式：$D_1=0,D_2=1,D_n=(n-1)(D_{n-1} + D_{n-2})=n!(\frac 1{2!}-\frac 1{3!}+\dots + (-1)^n\frac 1{n!})=\lfloor \frac{n!}e + 0.5 \rfloor$
* 卡塔兰数（$n$ 对括号合法方案数，$n$ 个结点二叉树个数，$n\times n$ 方格中对角线下方的单调路径数，凸 $n+2$ 边形的三角形划分数，$n$ 个元素的合法出栈序列数）：$C_n=\frac 1{n+1}\binom {2n}n=\frac{(2n)!}{(n+1)!n!}$

## 连分数

* 可表示为 $\frac{p_k}{q_k}=a_1+\frac{1}{a_2+\frac{1}{a_3+\frac{1}{a_4+...}}}=[a_1,a_2,a_3,a_4,...]$
* 可以根据线性递得到以下式子：

$$ p_k=\begin{cases} 
a_1 & k=1
 \\ a_1a_2+1 & k=2 
 \\ a_kp_{k-1}+p_{k-2} & k \ge 3
 \end{cases}$$
$$ q_k=\begin{cases} 
1 & k=1
 \\ a_2 & k=2 
 \\ a_kq_{k-1}+q_{k-2} & k \ge 3
 \end{cases}$$

* 写成矩阵形式即为：

$$\begin{bmatrix}
    p_n & p_{n-1} \\
    q_n & q_{n-1}
\end{bmatrix}=
\begin{bmatrix}
    1 & 0 \\
    0 & 1
\end{bmatrix}
\begin{bmatrix}
    a_1 & 1 \\
    1 & 0
\end{bmatrix}
\begin{bmatrix}
    a_2 & 1 \\
    1 & 0
\end{bmatrix}
...
\begin{bmatrix}
    a_n & 1 \\
    1 & 0
\end{bmatrix}
$$

## 常见狄利克雷卷积

### 积性函数
$$\epsilon(n)=[n=1]$$
$$1(n)=1$$
$$Id(n)=n$$
$$d(n)=\Sigma_{d|n}1$$
$$\sigma(n)=\Sigma_{d|n}d$$

### 卷积
$$\mu * 1 =\epsilon$$
$$\phi * 1=Id$$
$$1*1=d$$

## 杜教筛
$O(n^{2/3})$求积性函数前缀和。  
假设要求的积性函数为$f$，前缀和为$S$，能找到较为简单(前缀和好求)的积性函数$g$，使得$f*g=h$前缀和容易求出。那么有:
$$g(1)S(n)=\Sigma_{i=1}^{n}h(i)-\Sigma_{d=2}^{n}g(d)\cdot S(\lfloor n/d \rfloor)$$  
其中$g(1)$一般来说都是1，$h$和$g$的前缀和需要比较好算，然后就能记忆化搜索了。  

```c++ 
	//杜教筛欧拉函数 原理: phi * I = Id
	const int maxn=1e6+10;			//通常预处理到n^2/3为最优
	ll phi[maxn];
    unordered_map<int,ll> phi2;		//hash
    
	ll djsphi(int n)
	{
    	if (n < maxn)
        	return phi[n];
    	if (phi2[n])
        	return phi2[n];
    	ll ans = 1ll * n * (n + 1) / 2;	
    	for (int l = 2, r; l <= n; l = r + 1)
    	{
        	r = n / (n / l);
        	ans -= djsphi(n / l) * (r - l + 1);
    	}
    	return phi2[n] = ans;	//记忆化
	}

```

## 一些积性函数的表

| $id$ | $\mu(i)$ | $\phi(i)$ | $id$ | $\mu(i)$ | $\phi(i)$ | $id$ | $\mu(i)$ | $\phi(i)$ |
| ---- | -------- | --------- | ---- | -------- | --------- | ---- | -------- | --------- |
| 1    | 1        | 1         | 16   | 0        | 8         | 31*  | -1       | 30        |
| 2*   | -1       | 1         | 17*  | -1       | 16        | 32   | 0        | 16        |
| 3*   | -1       | 2         | 18   | 0        | 6         | 33   | 1        | 20        |
| 4    | 0        | 2         | 19*  | -1       | 18        | 34   | 1        | 16        |
| 5*   | -1       | 4         | 20   | 0        | 8         | 35   | 1        | 24        |
| 6    | 1        | 2         | 21   | 1        | 12        | 36   | 0        | 12        |
| 7*   | -1       | 6         | 22   | 1        | 10        | 37*  | -1       | 36        |
| 8    | 0        | 4         | 23*  | -1       | 22        | 38   | 1        | 18        |
| 9    | 0        | 6         | 24   | 0        | 8         | 39   | 1        | 24        |
| 10   | 1        | 4         | 25   | 0        | 20        | 40   | 0        | 16        |
| 11*  | -1       | 10        | 26   | 1        | 12        | 41*  | -1       | 40        |
| 12   | 0        | 4         | 27   | 0        | 18        | 42   | -1       | 12        |
| 13*  | -1       | 12        | 28   | 0        | 12        | 43*  | -1       | 42        |
| 14   | 1        | 6         | 29*  | -1       | 28        | 44   | 0        | 20        |
| 15   | 1        | 8         | 30   | -1       | 8         | 45   | 0        | 24        |

## 快速幂

```c++
ll quick(ll a, ll b)
{
    ll ret = 1;
    while (b)
    {
        if (b & 1)
            ret = ret * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ret;
}
```

## 快速乘

```c++
ll mul(ll a, ll b, ll m)
{
    ll ret = 0;
    while (b)
    {
        if (b & 1)
        {
            ret += a;
            if (ret >= m)
                ret -= m;
        }
        a += a;
        if (a >= m)
            a -= m;
        b >>= 1;
    }
    return ret;
}
```

```c++
ll mul(ll a, ll b, ll m)
{
    return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll mul(ll a, ll b, ll m)
{
    ll t = a * b - ll((long double)a * b / m) * m;
    return t < 0 ? t + m : t;
}
```  

## 扩展欧几里得算法

求解$a\cdot x+b\cdot y=gcd(a,b)$的一组特解。

```c++
ll exgcd(ll a, ll b, ll &x, ll &y) //返回gcd(a,b)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= x * (a / b);
    return d;
}
```

## 类欧几里得算法

$$F(a,b,c,n)=\Sigma_{i=0}^{n}\lfloor\frac{a*i+b}{c}\rfloor$$
$$G(a,b,c,n)=\Sigma_{i=0}^{n}\lfloor i*\frac{a*i+b}{c}\rfloor$$
$$H(a,b,c,n)=\Sigma_{i=0}^{n}(\lfloor \frac{a*i+b}{c}\rfloor)^2$$

通用方法：
1.   当$a\ge c$或者$b\ge c$时，通过$\lfloor \frac{a}{c} \rfloor = \lfloor \frac{a\%c}{c} \rfloor +\lfloor \frac{a}{c} \rfloor$ 展开化简。
2.   当$a < c$且$b < c$时，通过枚举直线下的点，交换枚举顺序展开化简后递归求解。
3.   注意边界条件： $a=0$，$n=0$。
4.   需要自己写多项取模相加/减/乘。

```c++
const ll mod = 1e9 + 7, inv2 = (mod + 1) / 2, inv6 = (mod + 1) / 6;
 
struct node
{
    ll f, g, h;
};
 
node solve(ll a, ll b, ll c, ll n)
{
    node ans, tmp;
    if (a == 0)
    {
        ans.f = (n + 1) * (b / c) % mod;
        ans.g = (b / c) * n % mod * (n + 1) % mod * inv2 % mod;
        ans.h = (n + 1) * (b / c) % mod * (b / c) % mod;
        return ans;
    }
    if (a >= c || b >= c)
    {
        tmp = solve(a % c, b % c, c, n);
        ans.f = (tmp.f + (a / c) * n % mod * (n + 1) % mod * inv2 % mod + (b / c) * (n + 1) % mod) % mod;
        ans.g = (tmp.g + (a / c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b / c) * n % mod * (n + 1) % mod * inv2 % mod) % mod;
        ans.h = ((a / c) * (a / c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod +
                 (b / c) * (b / c) % mod * (n + 1) % mod + (a / c) * (b / c) % mod * n % mod * (n + 1) % mod +
                 tmp.h + 2 * (a / c) % mod * tmp.g % mod + 2 * (b / c) % mod * tmp.f % mod) %
                mod;
        return ans;
    }
    ll m = (a * n + b) / c;
    tmp = solve(c, c - b - 1, a, m - 1);
    ans.f = ((n * (m % mod) % mod - tmp.f) % mod + mod) % mod;
    ans.g = ((n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod + mod) * inv2 % mod;
    ans.h = ((n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod + mod) % mod;
    return ans;
}
```

## 逆元

1. 使用费马小定理，要求模数p为素数。
2. 使用扩展欧几里得定理，不要求模数p为素数。  

```c++
ll inv(ll a, ll p) //求a关于p的逆元
{
    ll x, y;
    ll d = exgcd(a, p, x, y);
    if (d != 1)
        return -1;
    return (x % p + p) % p;
}
```

3. 基于$inv(a)=(p- \lfloor p/a \rfloor)*inv(p\%a)\%p$，在$O(n)$时间复杂度下求出逆元表。

```c++
void init()
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * 1LL * inv[mod % i] % mod;
}
```

## 组合数

$O(n)$时间复杂度内预处理出n以内的组合数。

```c++
void init() //inv,f,finv 都开ll
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod; //inv: 逆元
    f[0] = finv[0] = 1;                                //f: 阶乘 	finv:阶乘逆元(1/f)
    for (int i = 1; i < maxn; i++)
    {
        f[i] = f[i - 1] * i % mod;
        finv[i] = finv[i - 1] * inv[i] % mod;
    }
}

ll C(int n, int m) //C(n,m)
{
    if (m < 0 || m > n)
        return 0;
    return f[n] * finv[n - m] % mod * finv[m] % mod;
}
```

## 拉格朗日插值

$$L(x)=\sum\limits_{i=0}^{n}y_{i}l_i(x)$$  
其中  
$$l_i(x)=\prod_{j=0 \& j\neq i}^{n}\frac{x-x_j}{x_i-x_j}$$  

1. 需要组合数中的init。
2. arr: 插值数组  n: 项数(从0开始一共n+1项)  x: 需要求的值

```c++
ll lagrange(ll *arr, ll n, ll x)
{
    if (x <= n)
        return arr[x];
    ll ans = 0, sgn = n & 1 ? -1 : 1;
    for (int j = 0; j <= n; j++, sgn *= -1)
        ans = (ans + mod + sgn * f[x] % mod * finv[x - n - 1] % mod * inv[x - j] % mod * finv[j] % mod * finv[n - j] % mod * arr[j] % mod) % mod;
    return ans;
}
```

## 线性递推

### BM模板

要求:
1. 线性递推
2. 所有数都有逆元
3. k阶线性递推需要 2k 项

```c++
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;        //修改成题目要求的模数
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head
int _,n;
namespace linear_seq {
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<int> Md;
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
        //        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {//c.size()=阶数
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};
int main() 
{
    while (~scanf("%d",&n)) 
    {
        vector<int>v;       
        v.push_back(1);
        v.push_back(1);
        v.push_back(2);
        v.push_back(3);
        v.push_back(5);
        v.push_back(8);
        //VI{1,1,2,3,5,8}		解出斐波那契数列
        printf("i:%d  arr:%d\n",n,linear_seq::gao(v,n-1));
    }
}

```

## Fast Transfroming

### FFT

* 复数类实现，n为2的幂次

```c++
typedef double LD;
const LD PI = 3.14159265358979;
struct C
{
    LD r, i;
    C(LD r = 0, LD i = 0) : r(r), i(i) {}
    C operator+(const C &a) const
    {
        return C(r + a.r, i + a.i);
    }
    C operator-(const C &a) const
    {
        return C(r - a.r, i - a.i);
    }
    C operator*(const C &a) const
    {
        return C(r * a.r - i * a.i, r * a.i + i * a.r);
    }
};
void FFT(C x[], int n, int p)
{
    for (int i = 0, t = 0; i < n; ++i)
    {
        if (i > t)
            swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1)
            ;
    }
    for (int h = 2; h <= n; h <<= 1)
    {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h)
        {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j)
            {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1)
        for (int i = 0; i < n; ++i)
            x[i].r /= n;
}
void conv(C a[], C b[], int n)
{
    FFT(a, n, 1);
    FFT(b, n, 1);
    for (int i = 0; i < n; ++i)
        a[i] = a[i] * b[i];
    FFT(a, n, -1);
}
```

### NTT

```c++
const int maxn=1e6+7;
ll wn[maxn << 2], rev[maxn << 2];
int G=3;//998244353
int NTT_init(int n_) {
    int step = 0; int n = 1;
    for ( ; n < n_; n <<= 1) ++step;
	for(int i=1;i<n;i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
    int g = quick(G, (mod - 1) / n);
    wn[0] = 1;
    for (int i = 1; i <= n; ++i)
        wn[i] = wn[i - 1] * g % mod;
    return n;
}

void NTT(ll a[], int n, int f) {
	for(int i=0;i<n;i++) if (i < rev[i])
        std::swap(a[i], a[rev[i]]);
    for (int k = 1; k < n; k <<= 1) {
        for (int i = 0; i < n; i += (k << 1)) {
            int t = n / (k << 1);
			for(int j=0;j<k;j++){
                ll w = f == 1 ? wn[t * j] : wn[n - t * j];
                ll x = a[i + j];
                ll y = a[i + j + k] * w % mod;
                a[i + j] = (x + y) % mod;
                a[i + j + k] = (x - y + mod) % mod;
            }
        }
    }
    if (f == -1) {
        ll ninv = inv(n);
		for(int i=0;i<n;i++)
            a[i] = a[i] * ninv % mod;
    }
}
```

### FWT

* $C_k=\sum_{i \oplus j=k} A_i B_j$

```c++
template<typename T>
void fwt(ll a[], int n, T f) {
    for (int d = 1; d < n; d *= 2)
        for (int i = 0, t = d * 2; i < n; i += t)
            for(int j = 0; j < d; j++)
                f(a[i + j], a[i + j + d]);
}

void AND(ll& a, ll& b) { a += b; }
void OR(ll& a, ll& b) { b += a; }
void XOR (ll& a, ll& b) {
    ll x = a, y = b;
    a = (x + y) % mod;
    b = (x - y + mod) % mod;
}
void rAND(ll& a, ll& b) { a -= b; }
void rOR(ll& a, ll& b) { b -= a; }
void rXOR(ll& a, ll& b) {
    static ll inv2 = (mod + 1) / 2;
    ll x = a, y = b;
    a = (x + y) * inv2 % mod;
    b = (x - y + mod) * inv2 % mod;
}
```

### 万能FFT

```c++
namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;
    
    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};
```

## 离散对数

### BSGS

* ~~北上广深,拔山盖世~~应用于模数为质数

```c++
ll BSGS(ll a, ll b, ll p) // a^x = b (mod p)
{
    a %= p;
    if (!a && !b)
        return 1;
    if (!a)
        return -1;
    static map<ll, ll> mp;
    mp.clear();
    ll m = sqrt(p + 1.5);
    ll v = 1;
    for (int i = 1; i < m + 1; ++i)
    {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    ll vv = v;
    for (int i = 1; i < m + 1; ++i)
    {
        auto it = mp.find(vv);
        if (it != mp.end())
            return i * m - it->second;
        vv = vv * v % p;
    }
    return -1;
}
```

### exBSGS

```c++
ll exBSGS(ll a, ll b, ll p)  // a^x = b (mod p)
{
    a %= p; b %= p;
    if (a == 0) return b > 1 ? -1 : b == 0 && p != 1;
    LL c = 0, q = 1;
    while (1) {
        ll g = __gcd(a, p);
        if (g == 1) break;
        if (b == 1) return c;
        if (b % g) return -1;
        ++c; b /= g; p /= g; q = a / g * q % p;
    }
    static map<ll, ll> mp; mp.clear();
    ll m = sqrt(p + 1.5);
    ll v = 1;
    for(int i = 1; i< m + 1 ; i++)
    {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    for(int i = 1; i< m + 1; i++)
    {
        q = q * v % p;
        auto it = mp.find(q);
        if (it != mp.end()) return i * m - it->second + c;
    }
    return -1;
}
```

## 二次剩余

* $x==-1$ 时 无根
* 否则有两个解: $x$ , $p-x$

```c++
ll a, p, w;
struct T
{
    ll x, y;
};

T mul_two(T a, T b, ll p)
{
    T ans;
    ans.x = (a.x * b.x % p + a.y * b.y % p * w % p) % p;
    ans.y = (a.x * b.y % p + a.y * b.x % p) % p;
    return ans;
}

T qpow_two(T a, ll n, ll p)
{
    T ans;
    ans.x = 1;
    ans.y = 0;
    while (n)
    {
        if (n & 1)
            ans = mul_two(ans, a, p);
        n >>= 1;
        a = mul_two(a, a, p);
    }
    return ans;
}

ll qpow(ll a, ll n, ll p)
{
    ll ans = 1;
    a %= p;
    while (n)
    {
        if (n & 1)
            ans = ans * a % p;
        n >>= 1;
        a = a * a % p;
    }
    return ans % p;
}

ll Legendre(ll a, ll p)
{
    return qpow(a, (p - 1) >> 1, p);
}

int solve(ll n, ll p)
{
    if (n == 0)
        return 0;
    if (p == 2)
        return 1;
    if (Legendre(n, p) + 1 == p)
        return -1;
    ll a, t;
    while (1)
    {
        a = rand() % p;
        t = a * a - n;
        w = (t % p + p) % p;
        if (Legendre(w, p) + 1 == p)
            break;
    }
    T tmp;
    tmp.x = a;
    tmp.y = 1;
    T ans = qpow_two(tmp, (p + 1) >> 1, p);
    return ans.x;
}



```

## 中国剩余定理

* 逐项合并，支持不互质，无解返回-1
* 前置exgcd

```c++
ll CRT(ll *m, ll *r, ll n)
{
    if (!n)
        return 0;
    ll M = m[0], R = r[0], x, y, d;
    for (int i = 1; i < n; i++)
    {
        d = exgcd(M, m[i], x, y);
        if ((r[i] - R) % d)
            return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R >= 0 ? R : R + M;
}
```

## 线性基

```c++
template<typename T,int D>
struct Base{
	T a[D];
    int m;
	Base(){m = 0, memset(a, 0, sizeof(a));}
	void clear(){m = 0, memset(a, 0, sizeof(a));}
	bool ins(T x)
	{
		for(int i = D - 1; ~i; --i)
			if(x >> i & 1)
			{
				if(a[i]) x ^= a[i];
				else{
					m++;
					a[i] = x;return 1;
				}
			}
		return 0;
	}
};
//求交
template<typename T,int D>
Base<T,D> Merge(Base<T,D> A,Base<T,D> B)
{
    if(A.m==D) return B;
    if(B.m==D) return A;
    Base<T,D> All,C,D;
    All=A;
    D.ful();
    for(int i=D-1;i>=0;i--)
    {
        if(B.a[i]){
            T v=B.a[i],k=0;
            bool can=1;
            for(int j=D-1;j>=0;j--)
            {
                if(v>>j&1)
                {
                    if(All.a[j])
                    {
                        v^=All.a[j];
                        k^=D.a[j];
                    }
                    else{
                        can=0;
                        All.a[j]=v;
                        D.a[j]=k;
                        break;
                    }
                }
            }
            if(can)
            {
                T v=0;
                for(int j=D-1;j>=0;j--)
                {
                    if(k>>j&1)
                        v^=A.a[j];
                }
                C.ins(v);
            }
        }
    }
    return C;
}
```

## 高斯消元

```c++
const double eps=1e-8;
typedef vector<double> vec;
typedef vector<vec> mat;
int sz;
vec gauss_jordan(const mat& A, const vec& b)
{
    int n=A.size();
    mat B(n,vec(n+1));
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            B[i][j]=A[i][j];

    for(int i=0;i<n;i++) B[i][n]=b[i];
    for(int i=0;i<n;i++)
    {
        int pivot=i;
        for(int j=i;j<n;j++)
            if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;
        swap(B[i],B[pivot]);
        if(abs(B[i][i])<eps) return vec();
        for(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];
        for(int j=0;j<n;j++)
        {
            if(i!=j)
            {
                for(int k=i+1;k<=n;k++)
                    B[j][k]-=B[j][i]*B[i][k];
            }
        }
    }
    vec x(n);
    for(int i=0;i<n;i++)
        x[i]=B[i][n];
    return x;
}
```

## 素数测试

### miller_rabin

```c++
ll power(ll v, ll p, ll m)
{
    ll r = 1;
    while (p)
    {
        if (p & 1)
            r = r * v % m;
        v = v * v % m;
        p >>= 1;
    }

    return r;
}

bool witness(ll a, ll p)
{
    int k = 0;
    ll q = p - 1;
    while ((q & 1) == 0)
        ++k, q >>= 1;
    ll v = power(a, q, p);
    if (v == 1 || v == p - 1)
        return false; // probably prime number
    while (k-- != 0)
    {
        v = v * v % p;
        if (v == p - 1)
            return false;
    }

    return true; // composite number
}

bool miller_rabin(ll p)
{
    if (p == 1)
        return false;
    if (p == 2)
        return true;
    if (p % 2 == 0)
        return false;

    for (int i = 0; i != 50; ++i)
    {
        ll a = std::rand() % (p - 1) + 1;
        if (witness(a, p))
            return false;
    }

    return true;
}

```

## Pollard Rho

```c++
ll pollard_rho(ll n, int a)
{
    ll x = 2, y = 2, d = 1, k = 0, i = 1;
    while(d == 1)
    {
        ++k;
        x = mul_mod(x, x, n) + a;
        d = __gcd(x >= y ? x - y : y - x, n);
        if(k == i)
        {
            y = x;
            i <<= 1;
        }
    }
    if(d == n) return pollard_rho(n, a + 1);
    return d;
}
```

## 博弈
* 巴什博弈：P态为 $n\equiv 0(mod\ m+1)$
* 阶梯博弈：阶梯博弈等效为奇数号阶梯的nim博弈
* 威佐夫博弈：有两堆各若干个物品，两个人轮流从某一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
P态为$(y-x)\times \frac{\sqrt{5}+1}{2}=x$
* NP图、SG函数找规律，博弈dp
* 考虑模仿操作
