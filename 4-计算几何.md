## 二维几何 点和向量
```c++
#include <bits/stdc++.h>
using namespace std;
#define mp make_pair
#define fi first
#define se second
#define pb push_back
typedef double db;
const db eps = 1e-6;
const db pi = acos(-1);
int sign(db k)
{
    if (k > eps)
        return 1;
    else if (k < -eps)
        return -1;
    return 0;
}
int cmp(db k1, db k2) { return sign(k1 - k2); }

struct point
{
    db x, y;
    point operator+(const point &k1) const { return (point){k1.x + x, k1.y + y}; }
    point operator-(const point &k1) const { return (point){x - k1.x, y - k1.y}; }
    point operator*(db k1) const { return (point){x * k1, y * k1}; }
    point operator/(db k1) const { return (point){x / k1, y / k1}; }
    int operator==(const point &k1) const { return cmp(x, k1.x) == 0 && cmp(y, k1.y) == 0; }
    // 逆时针旋转
    point turn(db k1) { return (point){x * cos(k1) - y * sin(k1), x * sin(k1) + y * cos(k1)}; }
    point turn90() { return (point){-y, x}; }
    bool operator<(const point k1) const
    {
        int a = cmp(x, k1.x);
        if (a == -1)
            return 1;
        else if (a == 1)
            return 0;
        else
            return cmp(y, k1.y) == -1;
    }
    db abs() { return sqrt(x * x + y * y); }
    db abs2() { return x * x + y * y; }
    db dis(point k1) { return ((*this) - k1).abs(); }
    point unit()
    {
        db w = abs();
        return (point){x / w, y / w};
    }
    void scan()
    {
        double k1, k2;
        scanf("%lf%lf", &k1, &k2);
        x = k1;
        y = k2;
    }
    void print() { printf("%.11lf %.11lf\n", x, y); }
    db getw() { return atan2(y, x); }
};
db cross(point k1, point k2) { return k1.x * k2.y - k1.y * k2.x; }
db dot(point k1, point k2) { return k1.x * k2.x + k1.y * k2.y; }

```

## 面积，凸包
```c++
struct cmp2		//极角排序，需要一个点作为基点
{
    point p;
    cmp2(const point& p0){p=p0;}
    bool operator()(const point& p1,const point& p2)
    {
        point a=p1,b=p2;
        int m=dir(p,a,b);
        if(m>0)	return true;
        else if(m==0&&cmp((b-p).abs(),(a-p).abs())==1)	return true;
        else	return false;	
    }
};
sort(v.begin()+1,v.end(),cmp2(v[0]));           //使用


vector<point> getconvex(vector<point> v)        //Graham获取凸包,<0:边上可以有点 <=0:边上不能有点
{
    int n=v.size();
    vector<point> ans(n);
    sort(v.begin(),v.end());
    sort(v.begin()+1,v.end(),cmp2(v[0]));
    ans.push_back(v[0]);	ans.push_back(v[1]);
    int top=2;
    for(int i=2;i<n;i++)
    {
        while(dir(ans[top-2],ans[top-1],v[i])<0)	top--;
        ans[top++]=v[i];
    }
    ans.resize(top);
    return ans;
}

vector<point> ConvexHull(vector<point> A, int flag = 1) //Andrew凸包
{                                                       // flag=0 不严格 flag=1 严格
    int n = A.size();
    vector<point> ans(n * 2);
    sort(A.begin(), A.end());
    int now = -1;
    for (int i = 0; i < A.size(); i++)
    {
        while (now > 0 && sign(cross(ans[now] - ans[now - 1], A[i] - ans[now - 1])) < flag)
            now--;
        ans[++now] = A[i];
    }
    int pre = now;
    for (int i = n - 2; i >= 0; i--)
    {
        while (now > pre && sign(cross(ans[now] - ans[now - 1], A[i] - ans[now - 1])) < flag)
            now--;
        ans[++now] = A[i];
    }
    ans.resize(now);
    return ans;
}
```
