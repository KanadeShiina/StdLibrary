## 二维几何 点和向量
```c++
#define mp make_pair
#define fi first
#define se second
#define pb push_back

#include <bits/stdc++.h>
using namespace std;
typedef double db;

const db eps=1e-6;
const db pi=acos(-1.0);

int sign(db k)
{
    if(k>eps)   return 1;
    else if(k<-eps) return -1;
    return 0;
}

int cmp(db k1,db k2)    //k1>k2 return 1; k1<k2 return -1; k1=k2 return 0;
{
    return sign(k1-k2);
}

struct point
{
    db x,y;
    point(){}
    point(db _x,db _y):x(_x),y(_y){}
    point operator + (const point& k) const { return (point){x+k.x,y+k.y}; }
    point operator - (const point& k) const { return (point){x-k.x,y-k.y}; }
    point operator * (db k) const { return (point){x*k,y*k}; }
    point operator / (db k) const { return (point){x/k,y/k}; }
    int operator == (const point& k) const { return cmp(x,k.x)==0&&cmp(y,k.y); }
    double operator ^ (const point& k) const { return x*k.y-y*k.x; }
    double operator * (const point& k) const { return x*k.x+y*k.y; }

    db abs2() { return x*x+y*y; }
    db abs() { return sqrt(x*x+y*y); }
    db dis(point k) { return ((*this)-k).abs(); }

    void scan(){double k1,k2;   scanf("%lf%lf",&k1,&k2);    x=k1;y=k2;}
    void print(){printf("%.8f %.8f\n",x,y);}

    bool operator < (const point k1) const{
        int a=cmp(x,k1.x);
        if (a==-1) return 1; else if (a==1) return 0; else return cmp(y,k1.y)==-1;
    }

};

ostream &operator <<(ostream& os,const point &p)    {return (os<<"("<<p.x<<","<<p.y<<")");}
istream &operator >>(istream& is,point &p)  {return (is>>p.x>>p.y);}

struct line
{
    point s,e;
    line(){}
    line(point _s,point _e):s(_s),e(_e) {}

    double len() { return (e-s).abs(); }
};

int dir(point o,point a,point b)				//判断向量ob在向量oa的什么方向 1：逆时针 -1：顺时针 0：重合、共线
{
    point oa=a-o,ob=b-o;
    return oa^ob;
}

```

## 面积，凸包
```c++
struct cmp2		//极角排序，需要一个点作为基点
{
    point p;
    cmp2(const point& p0){p=p0;}
    bool operator()(const point& p1,const point& p2)
    {
        point a=p1,b=p2;
        int m=dir(p,a,b);
        if(m>0)	return true;
        else if(m==0&&cmp((b-p).abs(),(a-p).abs())==1)	return true;
        else	return false;	
    }
};


vector<point> getconvex(vector<point> v)        //Graham获取凸包,<0:边上可以有点 <=0:边上不能有点
{
    int n=v.size();
    vector<point> ans(n);
    sort(v.begin(),v.end());
    sort(v.begin()+1,v.end(),cmp2(v[0]));
    ans.push_back(v[0]);	ans.push_back(v[1]);
    int top=2;
    for(int i=2;i<n;i++)
    {
        while(dir(ans[top-2],ans[top-1],v[i])<0)	top--;
        ans[top++]=v[i];
    }
    ans.resize(top);
    return ans;
}
```
