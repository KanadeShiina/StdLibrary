# 图论
## 树链剖分
* 维护点权，边权要下放

```c++
int fa[maxn], dep[maxn], maxson[maxn], son[maxn]; //dfs数组
int top[maxn], dfn[maxn], tot;                    //link数组
int dfs(int u)
{
    int ret = 0;
    for (int i = head[u]; i != -1; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (v == fa[u])
            continue;
        fa[v] = u;
        dep[v] = dep[u] + 1;
        int sz = dfs(v);
        ret += sz;
        if (sz > maxson[u])
        {
            maxson[u] = sz;
            son[u] = v;
        }
    }
    return ret + 1;
}
void link(int u, int t)
{
    dfn[u] = ++tot;
    top[u] = t;
    if (son[u])
        link(son[u], t);
    for (int i = head[u]; i != -1; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (v == fa[u] || v == son[u])
            continue;
        link(v, v);
    }
}
void hld()
{
    dfs(1);
    link(1, 1);
}

```

## 边双联通分量

* 将无向图缩成一棵树
* 有重边需要做一些改动
* 稍微改一下就是强联通缩点了

```c++
int dfn[maxn], low[maxn], bel[maxn];
int n, m;
int ti, scc; //时间戳与联通分量计数
stack<int> st;
void dfs(int u, int fa)
{
    dfn[u] = low[u] = ++ti;
    st.push(u);
    for (int i = head[u]; i != -1; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (v == fa)
            continue;
        if (!dfn[v])
        {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
        }
        else if (!bel[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u])
    {
        scc++;
        while (1)
        {
            int t = st.top();
            st.pop();
            bel[t] = scc;
            if (u == t)
                break;
        }
    }
}
void DCC()
{
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            dfs(i, -1);
    for (int i = 0; i < cur; i++) //遍历所有边建图
    {
        int u = edge[i].from, v = edge[i].to;
        if (bel[u] != bel[v])
            addedge2(bel[u], bel[v]);
    }
}
```

## 虚树

* 注意每次清空虚树图
* 根节点必定是关键点

```c++
const int maxn = 5e5 + 7;
int ti; //时间戳
int ts[maxn];
int depth[maxn];
int far[maxn][22];
int dfn[maxn];
void dfs(int u, int fa = -1)
{
    dfn[u] = ++ti; //dfs序
    ts[ti] = u;    //括号序列时间戳映射
    for (int i = head[u]; i != -1; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (v == fa)
            continue;
        depth[v] = depth[u] + 1;
        far[v][0] = u; //可能会用到的倍增数组
        dfs(v, u);
        ts[++ti] = u;
    }
}
int ST[maxn][22]; //LCA转RMQ用ST表求
bool cmp(int x, int y) { return depth[x] < depth[y]; }
void RMQ()
{
    for (int i = 1; i <= ti; i++)
        ST[i][0] = ts[i];
    for (int j = 1; (1 << j) <= ti; j++)
    {
        for (int i = 1; i + (1 << (j - 1)) - 1 <= ti; i++)
        {
            if (cmp(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]))
                ST[i][j] = ST[i][j - 1];
            else
                ST[i][j] = ST[i + (1 << (j - 1))][j - 1];
        }
    }
}
int LCA(int u, int v)
{
    int l = dfn[u], r = dfn[v];
    if (l > r)
        swap(l, r);
    int k = 31 - __builtin_clz(r - l + 1);
    if (cmp(ST[l][k], ST[r - (1 << k) + 1][k]))
        return ST[l][k];
    return ST[r - (1 << k) + 1][k];
}
void Virtual(vector<int> &all) //关键点
{
    int st[maxn]; //栈模拟访问
    int top = 0;
    for (auto &u : all)
    {
        if (top == 0)
            st[++top] = u;
        else
        {
            int lca = LCA(st[top], u);
            while (top > 1 && dfn[st[top - 1]] >= dfn[lca])
            { //栈中至少有两个元素，则开始向上连边
                access(st[top],st[top-1]));
                top--;
            }
            if (lca != st[top]) //最后将lca也放进去
            {
                access(st[top], lca);
                st[top] = lca;
            }
            st[++top] = u;
        }
    }
    while (top > 1) //所有元素出栈
    {
        access(st[top], st[top - 1]);
        --top;
    }
}

```

## 网络流

### DINIC
```c++
const int maxn = 1e3 + 7;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int from, to, cap, flow;
};
struct Dinic
{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[maxn];
    bool vis[maxn];
    int d[maxn];
    int cur[maxn];

    void AddEdge(int from, int to, int cap, int c = 0)
    {
        edges.push_back(Edge{from, to, cap, 0});
        edges.push_back(Edge{to, from, c, 0});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool BFS()
    {
        memset(vis, 0, sizeof(vis));
        queue<int> q;
        q.push(s);
        d[s] = 0;
        vis[s] = 1;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge &e = edges[G[u][i]];
                if (!vis[e.to] && e.cap > e.flow)
                {
                    vis[e.to] = 1;
                    d[e.to] = d[u] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int u, int dist)
    {
        if (u == t || dist == 0)
            return dist;
        int flow = 0, f;
        for (int &i = cur[u]; i < G[u].size(); i++)
        {
            Edge &e = edges[G[u][i]];
            if (d[u] + 1 == d[e.to] && (f = DFS(e.to, min(dist, e.cap - e.flow))) > 0)
            {
                e.flow += f;
                edges[G[u][i] ^ 1].flow -= f;
                flow += f;
                dist -= f;
                if (!dist)
                    break;
            }
        }
        return flow;
    }
    int Maxflow(int s, int t)
    {
        this->s = s;
        this->t = t;
        int flow = 0;
        while (BFS())
        {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }
};
```

### 费用流
```c++
const int maxn = 1e3 + 7;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int from, to, cap, flow, cost;
};
struct MCMF
{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];
    int d[maxn]; //最短路数组
    int p[maxn]; //记录路径
    int a[maxn]; //记录流量
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++)
            G[i].clear();
        edges.clear();
    }
    void addedge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool spfa(int s, int t, int &flow, int &cost)
    {
        for (int i = 0; i < n; i++)
            d[i] = INF;
        memset(inq, 0, sizeof(inq));
        d[s] = 0;
        inq[s] = 1;
        p[s] = 0;
        a[s] = INF;
        queue<int> q;
        q.push(s);
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge &e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;             //松弛
                    p[e.to] = G[u][i];                   //记录上一个点
                    a[e.to] = min(a[u], e.cap - e.flow); //流量控制
                    if (!inq[e.to])
                    {
                        q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if (d[t] == INF)
            return false; //不存在最短路
        flow += a[t];
        cost += d[t] * a[t];
        int u = t;
        while (u != s)
        {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
            u = edges[p[u]].from;
        }
        return true;
    }
    int Mincost(int s, int t)
    {
        int flow = 0, cost = 0;
        while (spfa(s, t, flow, cost))
            ;
        return cost;
    }
};
```
##最小树形图
```c++
struct Edge//边的权和顶点
{
    int u, v;
    ll w;
}edge[maxn * maxn];
int pre[maxn], id[maxn], vis[maxn], pos;
ll in[maxn];//存最小入边权,pre[v]为该边的起点

ll Directed_MST(int root, int V, int E)
{
    ll ret = 0;//存最小树形图总权值
    while(true)
    {
        int i;
        //1.找每个节点的最小入边
        for( i = 0; i < V; i++)
            in[i] = INF;//初始化为无穷大
        for( i = 0; i < E; i++)//遍历每条边
        {
            int u = edge[i].u;
            int v = edge[i].v;
            if(edge[i].w < in[v] && u != v)//说明顶点v有条权值较小的入边  记录之
            {
                pre[v] = u;//节点u指向v
                in[v] = edge[i].w;//最小入边
                if(u == root)//这个点就是实际的起点
                    pos = i;
            }
        }
        for( i = 0; i < V; i++)//判断是否存在最小树形图
        {
            if(i == root)
                continue;
            if(in[i] == INF)
                return -1;//除了根以外有点没有入边,则根无法到达它  说明它是独立的点 一定不能构成树形图
        }
        //2.找环
        int cnt = 0;//记录环数
        memset(id, -1, sizeof(id));
        memset(vis, -1, sizeof(vis));
        in[root] = 0;
        for( i = 0; i < V; i++) //标记每个环
        {
            ret += in[i];//记录权值
            int v = i;
            while(vis[v] != i && id[v] == -1 && v != root)
            {
                vis[v] = i;
                v = pre[v];
            }
            if(v != root && id[v] == -1)
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = cnt;//标记节点u为第几个环
                id[v] = cnt++;
            }
        }
        if(cnt == 0)
            break; //无环   则break
        for( i = 0; i < V; i++)
            if(id[i] == -1)
                id[i] = cnt++;
            //3.建立新图   缩点,重新标记
            for( i = 0; i < E; i++)
            {
                int u = edge[i].u;
                int v = edge[i].v;
                edge[i].u = id[u];
                edge[i].v = id[v];
                if(id[u] != id[v])
                    edge[i].w -= in[v];
            }
            V = cnt;
            root = id[root];
    }
    return ret;
}
```

## 网络流基本建图技巧
* 最大流=最小割
* 拆点技巧
* 最小点覆盖=最大匹配
* 最大独立集=点数-最小覆盖集
* 最小路径覆盖
最小路径覆盖=原图节点数-最大匹配
拆点分出入度变二分图。
一开始把每个点都视为一条路径，每次匹配相当于合并两条路径，匹配几次路径数就少了多少。

* 上下界网络流
先让每条边有下界那么多的流量，然后再去增大某些弧的流量使流量平衡。
具体操作即为平衡与补流。
对于入流大于出流的点，由S向其建边补流，对于出流大于入流的点，向T连边平衡。
具体操作时用一个数组统计入流与出流差即可。
对于有源汇的情况，加一条由t到s，容量为INF的边，改造成循环流即可。

* 最小流
首先按照有源汇可行流的方法建模,但是不要建立<t,s>这条弧。
然后在这个图上,跑从附加源 ss 到附加汇 tt 的最大流。
这时候再添加弧<t,s>
再跑从 ss 到 tt 的最大流,就是原图的最小流。

* 区间 k 覆盖
最小费用最大流，[i,j]区间覆盖
`add_edge(i,j,1,-w)`
点之间连 `add_edge(i,i+1,k,0)`

* 优化建图
目前已知的有二进制优化和线段树优化。

* 最大权闭合子图
建图：
设置超级源汇
S和所有的正权的点连接权值为点权的边，所有点权为负的点和T连接权值为点权绝对值的边。然后如果选择了某个v点才可以选u点，那么把u向v连接一条权值为INF的边。
最大点权和=正点权和-最小割

## 一些公式
* Carley format : $(n+1)^{n-1},T_{n,k}=kn^{n-k-1}$
