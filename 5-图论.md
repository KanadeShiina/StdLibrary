# 图论
## 树链剖分
* 维护点权，边权要下放

```c++
int fa[maxn],dep[maxn],maxson[maxn],son[maxn];//dfs数组
int top[maxn],dfn[maxn],tot;//link数组
int dfs(int u)
{
	int ret=0;
	for(int i=head[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u]) continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		int sz=dfs(v);
		ret+=sz;
		if(sz>maxson[u])
		{
			maxson[u]=sz;
			son[u]=v;
		}
	}
	return ret+1;
}
void link(int u,int t)
{
	dfn[u]=++tot;
	top[u]=t;
	if(son[u])
		link(son[u],t);
	for(int i=head[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u]||v==son[u]) continue;
		link(v,v);
	}
}
void hld()
{
	dfs(1);
	link(1,1);
}

```

## 边双联通分量

* 将无向图缩成一棵树
* 有重边需要做一些改动
* 稍微改一下就是强联通缩点了

```c++
int dfn[maxn],low[maxn],bel[maxn];
int n,m;
int ti,scc;//时间戳与联通分量计数
stack<int> st;
void dfs(int u,int fa)
{
	dfn[u] = low[u] = ++ti;
	st.push(u);
	for(int i = head[u];i != -1;i = edge[i].nxt)
	{
		int v = edge[i].to;
		if(v == fa) continue;
		if(!dfn[v])
		{
			dfs(v,u);
			low[u] = min(low[u] ,low[v]);
		}
		else if(!bel[v])
			low[u] = min(low[u],dfn[v]);
	}
	if(dfn[u] == low[u])
	{
		scc++;
		while(1)
		{
			int t = st.top();st.pop();
			bel[t] = scc;
			if(u == t) break;
		}
	}
}
void DCC()
{
	for(int i = 1;i <= n;i++)
		if(!dfn[i])
			dfs(i ,-1);
	for(int i = 0;i < cur;i++)//遍历所有边建图
	{
		int u = edge[i].from,v = edge[i].to;
		if(bel[u] != bel[v])
			addedge2(bel[u] ,bel[v]);
	}
}
```

## 网络流

### DINIC
```c++
const int maxn=1e3+7;
const int INF=0x3f3f3f3f;
struct Edge{
	int from,to,cap,flow;
};
struct Dinic{
	int n,m,s,t;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool vis[maxn];
	int d[maxn];
	int cur[maxn];

	void AddEdge(int from,int to,int cap,int c=0)
	{
		edges.push_back(Edge {from,to,cap,0});
		edges.push_back(Edge {to,from,c,0});
		m=edges.size();
		G[from].push_back(m-2);
		G[to].push_back(m-1);
	}

	bool BFS()
	{
		memset(vis,0,sizeof(vis));
		queue<int> q;
		q.push(s);
		d[s]=0;
		vis[s]=1;
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(int i=0;i<G[u].size();i++)
			{
				Edge& e=edges[G[u][i]];
				if(!vis[e.to]&&e.cap>e.flow)
				{
					vis[e.to]=1;
					d[e.to]=d[u]+1;
					q.push(e.to);
				}
			}
		}
		return vis[t];
	}
	int DFS(int u,int dist)
	{
		if(u==t||dist==0) return dist;
		int flow=0,f;
		for(int& i=cur[u];i<G[u].size();i++)
		{
			Edge& e=edges[G[u][i]];
			if(d[u]+1==d[e.to]&&(f=DFS(e.to,min(dist,e.cap-e.flow)))>0)
			{
				e.flow+=f;
				edges[G[u][i]^1].flow-=f;
				flow+=f;
				dist-=f;
				if(!dist) break;
			}
		}
		return flow;
	}
	int Maxflow(int s,int t)
	{
		this->s=s;this->t=t;
		int flow=0;
		while(BFS())
		{
			memset(cur,0,sizeof(cur));
			flow+=DFS(s,INF);
		}
		return flow;
	}
};
```

### 费用流
```c++
const int maxn=1e3+7;
const int INF=0x3f3f3f3f;
struct Edge{
	int from,to, cap,flow,cost;
};
struct MCMF{
	int n,m,s,t;
	vector<Edge> edges;
	vector<int> G[maxn];
	int inq[maxn];
	int d[maxn];//最短路数组
	int p[maxn];//记录路径
	int a[maxn];//记录流量
	void init(int n)
	{
		this->n=n;
		for(int i=0;i<n;i++) G[i].clear();
		edges.clear();
	}
	void addedge(int from,int to,int cap,int cost)
	{
		edges.push_back(Edge {from,to,cap,0,cost});
		edges.push_back(Edge {to,from,0,0,-cost});
		m=edges.size();
		G[from].push_back(m-2);
		G[to].push_back(m-1);
	}
	bool spfa(int s,int t,int &flow,int &cost)
	{
		for(int i=0;i<n;i++) d[i]=INF;
		memset(inq,0,sizeof(inq));
		d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;
		queue<int> q;
		q.push(s);
		while(!q.empty())
		{
			int u=q.front();q.pop();
			inq[u]=0;
			for(int i=0;i<G[u].size();i++)
			{
				Edge &e=edges[G[u][i]];
				if(e.cap>e.flow&&d[e.to]>d[u]+e.cost)
				{
					d[e.to]=d[u]+e.cost;//松弛
					p[e.to]=G[u][i];//记录上一个点
					a[e.to]=min(a[u],e.cap-e.flow);//流量控制
					if(!inq[e.to])
					{
						q.push(e.to);
						inq[e.to]=1;
					}
				}
			}
		}
		if(d[t]==INF) return false;//不存在最短路
		flow+=a[t];
		cost+=d[t]*a[t];
		int u=t;
		while(u!=s)
		{
			edges[p[u]].flow+=a[t];
			edges[p[u]^1].flow-=a[t];
			u=edges[p[u]].from;
		}
		return true;
	}
	int Mincost(int s,int t)
	{
		int flow=0,cost=0;
		while(spfa(s,t,flow,cost));
		return cost;
	}
};
```