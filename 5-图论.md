# 图论
## 树链剖分
* 维护点权，边权要下放

```c++
int fa[maxn],dep[maxn],maxson[maxn],son[maxn];//dfs数组
int top[maxn],dfn[maxn],tot;//link数组
int dfs(int u)
{
	int ret=0;
	for(int i=head[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u]) continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		int sz=dfs(v);
		ret+=sz;
		if(sz>maxson[u])
		{
			maxson[u]=sz;
			son[u]=v;
		}
	}
	return ret+1;
}
void link(int u,int t)
{
	dfn[u]=++tot;
	top[u]=t;
	if(son[u])
		link(son[u],t);
	for(int i=head[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u]||v==son[u]) continue;
		link(v,v);
	}
}
void hld()
{
	dfs(1);
	link(1,1);
}

```

## 边双联通分量

* 将无向图缩成一棵树
* 有重边需要做一些改动
* 稍微改一下就是强联通缩点了

```c++
int dfn[maxn],low[maxn],bel[maxn];
int n,m;
int ti,scc;//时间戳与联通分量计数
stack<int> st;
void dfs(int u,int fa)
{
	dfn[u] = low[u] = ++ti;
	st.push(u);
	for(int i = head[u];i != -1;i = edge[i].nxt)
	{
		int v = edge[i].to;
		if(v == fa) continue;
		if(!dfn[v])
		{
			dfs(v,u);
			low[u] = min(low[u] ,low[v]);
		}
		else if(!bel[v])
			low[u] = min(low[u],dfn[v]);
	}
	if(dfn[u] == low[u])
	{
		scc++;
		while(1)
		{
			int t = st.top();st.pop();
			bel[t] = scc;
			if(u == t) break;
		}
	}
}
void DCC()
{
	for(int i = 1;i <= n;i++)
		if(!dfn[i])
			dfs(i ,-1);
	for(int i = 0;i < cur;i++)//遍历所有边建图
	{
		int u = edge[i].from,v = edge[i].to;
		if(bel[u] != bel[v])
			addedge2(bel[u] ,bel[v]);
	}
}
```