# 数据结构
## 无旋Treap
* 大根堆

### 维护集合
* 小于k分为左子树，大于等于k分为右子树

```c++
struct Treap{
	Treap *l,*r;
	int val,prior;
	Treap(int _val):val(_val),l(NULL),r(NULL),prior(rnd()){}
};
typedef Treap* pt;
void split(pt o,int k,pt &l,pt &r)
{
	if(!o) l=r=NULL;
	else if(o->val>=k) split(o->l,k,l,o->l),r=o;
	else split(o->r,k,o->r,r),l=o;
}
void merge(pt &o,pt l,pt r)
{
	if(!l||!r) o=l?l:r;
	else if(l->prior>r->prior) merge(l->r,l->r,r),o=l;
	else merge(r->l,l,r->l),o=r;
}
pt root;
```

## ST表
* 一维
```C++
void ST(int n)//处理出[1,n]的RMQ
{
    for (int i = 1; i <= n; i++)
        dp[i][0] = arr[i];

    for (int j = 1; (1 << j) <= n; j++)
    {
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = min(dp[i][j - 1],dp[i + (1 << (j - 1))][j - 1]);
    }
}

int query(int l, int r)
{
    int k = 31 - __builtin_clz(r - l + 1);
    return min(dp[l][k],dp[r - (1 << k) + 1][k]);
}
```

## 树状数组
* 区间最值 
* $O(log^2(n))$
```C++
int a[N],tree[N];//a[]存原始数据，tree[]存树状数组
int n;
//先改a[x],然后update(x)
void update(int x)
{
	int lx, i;
	while (x < n)
	{
		tree[x] = a[x];
		lx = -x&x;
		for (i = 1; i < lx; i <<= 1)
			tree[x] = max(tree[x], tree[x-i]);
		x += -x&x;
	}		
}
int query(int x, int y)//[x,y]区间最值
{
	int ret = 0;
	while (y >= x)
	{
		ret = max(a[y], ret);
		y --;
		for (; y - (-y&y) >= x; y -= -y&y)
			ret = max(tree[y], ret);
	}
	return ret;
}
```