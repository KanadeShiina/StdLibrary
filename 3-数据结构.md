# 数据结构
## 无旋Treap
* 大根堆

### 维护集合
* 小于k分为左子树，大于等于k分为右子树

```c++
struct Treap
{
    Treap *l, *r;
    int val, prior;
    Treap(int _val) : val(_val), l(NULL), r(NULL), prior(rnd()) {}
};
typedef Treap *pt;
void split(pt o, int k, pt &l, pt &r)
{
    if (!o)
        l = r = NULL;
    else if (o->val >= k)
        split(o->l, k, l, o->l), r = o;
    else
        split(o->r, k, o->r, r), l = o;
}
void merge(pt &o, pt l, pt r)
{
    if (!l || !r)
        o = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), o = l;
    else
        merge(r->l, l, r->l), o = r;
}
pt root;
```

## ST表
* 一维
```C++
void ST(int n) //处理出[1,n]的RMQ
{
    for (int i = 1; i <= n; i++)
        dp[i][0] = arr[i];

    for (int j = 1; (1 << j) <= n; j++)
    {
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
    }
}

int query(int l, int r)
{
    int k = 31 - __builtin_clz(r - l + 1);
    return min(dp[l][k], dp[r - (1 << k) + 1][k]);
}
```

## 树状数组
* 区间最值 
* $O(log^2(n))$
```C++
int a[maxn], tree[maxn]; //a[]存原始数据，tree[]存树状数组
int n;
//先改a[x],然后update(x)
void update(int x)
{
    int lx, i;
    while (x < n)
    {
        tree[x] = a[x];
        lx = -x & x;
        for (i = 1; i < lx; i <<= 1)
            tree[x] = max(tree[x], tree[x - i]);
        x += -x & x;
    }
}
int query(int x, int y) //[x,y]区间最值
{
    int ret = 0;
    while (y >= x)
    {
        ret = max(a[y], ret);
        y--;
        for (; y - (-y & y) >= x; y -= -y & y)
            ret = max(tree[y], ret);
    }
    return ret;
}
```
* 区间修改、区间查询（查询前缀和的前缀和）
```c++
int tr[maxn], trr[maxn];
void add(int x, int val)
{
    for (int i = x; i < maxn; i += i & -i)
    {
        tr[i] += val;
        trr[i] += x * val;
    }
}
void add(int l, int r, int val)
{
    add(l, val);
    add(r + 1, -val);
}
int sum(int x)
{
    int ret = 0;
    for (int i = x; i > 0; i -= i & -i)
        ret += (x + 1) * tr[i] - trr[i];
    return ret;
}
int sum(int l, int r) { return sum(r) - sum(l - 1); }
```

## 笛卡尔树

* $O(n)$建树，大根堆

```c++
stack<int> st;
for (int i = 0; i < n; i++)
{
    int last = -1;
    while (!st.empty() && arr[i] > arr[st.top()])
        last = st.top(), st.pop();
    if (!st.empty())
        rc[st.top()] = i, fa[i] = st.top();
    lc[i] = last;
    if (~last)
        fa[last] = i;
    st.push(i);
}
int root = -1;
for (int i = 0; i < n; i++)
    if (!~fa[i])
        root = i;
```

## 主席树优化建图

* 只写了点向区间连边

```c++
struct Node
{
    Node *l, *r;
    int id;
    Node(int _id) : id(_id), l(NULL), r(NULL) {}
};
Node *rt[maxn];
int tot; //编号
int ins[maxn];
#define Lson L, mid, o->l
#define Rson mid + 1, R, o->r
void build(int L, int R, Node *&o)
{
    o = new Node(tot++);
    if (L == R)
    {
        addedge(o->id, L);
        return;
    }
    int mid = L + R >> 1;
    build(Lson);
    build(Rson);
    addedge(o->id, o->l->id);
    addedge(o->id, o->r->id);
}
void update(int p, int l, int r, int L, int R, Node *o)
{
    if (l <= L && r >= R)
    {
        addedge(ins[p], o->id);
        return;
    }
    int mid = L + R >> 1;
    if (l <= mid)
        update(p, l, r, Lson);
    if (r > mid)
        update(p, l, r, Rson);
}
void add(int pos, int L, int R, Node *&o, Node *pre)
{
    o = new Node(tot++);
    if (L == R)
    {
        addedge(o->id, ins[pos]);
        return;
    }
    int mid = L + R >> 1;
    if (pos <= mid)
    {
        add(pos, Lson, pre->l);
        o->r = pre->r;
    }
    else
    {
        add(pos, Rson, pre->r);
        o->l = pre->l;
    }
    addedge(o->id, o->l->id);
    addedge(o->id, o->r->id);
}

```

## Link-Cut Tree

* 修改点值先makeroot

```c++
#define lc ch[x][0]
#define rc ch[x][1]
namespace LCT
{
int fa[maxn], ch[maxn][2], val[maxn], pre[maxn], lz[maxn];
inline bool nroot(int x)
{
    return ch[fa[x]][0] == x || ch[fa[x]][1] == x;
}
inline void pushup(int x) //维护链信息
{
    pre[x] = pre[lc] ^ pre[rc] ^ val[x];
}
inline void pushr(int x)
{
    swap(lc, rc);
    lz[x] ^= 1;
} //反转
inline void pushdown(int x)
{
    if (lz[x])
    {
        if (lc)
            pushr(lc);
        if (rc)
            pushr(rc);
        lz[x] = 0;
    }
}
void rotate(int x) //单次旋转
{
    int y = fa[x], z = fa[y], k = ch[y][1] == x, w = ch[x][!k];
    if (nroot(y))
        ch[z][ch[z][1] == y] = x;
    ch[x][!k] = y;
    ch[y][k] = w;
    if (w)
        fa[w] = y;
    fa[y] = x;
    fa[x] = z;
    pushup(y);
}
void pushall(int x) //递归下放标记
{
    if (nroot(x))
        pushall(fa[x]);
    pushdown(x);
}
void splay(int x)
{
    pushall(x);
    while (nroot(x))
    {
        int y = fa[x];
        int z = fa[y];
        if (nroot(y))
            rotate((ch[y][0] == x) ^ (ch[z][0] == y) ? x : y);
        rotate(x);
    }
    pushup(x);
}
void access(int x)
{
    for (int y = 0; x; x = fa[y = x])
    {
        splay(x);
        rc = y;
        pushup(x);
    }
}
void makeroot(int x)
{
    access(x);
    splay(x);
    pushr(x);
}
int findroot(int x)
{
    access(x);
    splay(x);
    while (lc)
        pushdown(x), x = lc;
    splay(x);
    return x;
}
void split(int x, int y)
{
    makeroot(x);
    access(y);
    splay(y);
}
void link(int x, int y)
{
    makeroot(x);
    if (findroot(y) != x)
        fa[x] = y;
}
void cut(int x, int y)
{
    makeroot(x);
    if (findroot(y) == x && fa[y] == x && !ch[y][0])
    {
        fa[y] = ch[x][1] = 0;
        pushup(x);
    }
}
}; // namespace LCT
```